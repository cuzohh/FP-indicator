//@version=6
indicator("first presented gaps", overlay=true, max_lines_count=500, max_labels_count=500)

// ════════════════════════════════════════════════════════════════════════════
// INPUTS
// ════════════════════════════════════════════════════════════════════════════

timezone = input.string("America/New_York", "Timezone", options=["America/New_York", "Europe/London", "UTC"], group="Settings")
maxDaysToDisplay = input.int(20, "Days to Display", minval=1, maxval=20, group="Display")
showGaps = input.bool(true, "Show Gaps", group="Display")
lineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Display")
bullishColorDark = input.color(#008000, "Bullish Color", group="Display")
bearishColorDark = input.color(#B22222, "Bearish Color", group="Display")

// Always store up to 20 days
maxDaysToStore = 20

// Check if symbol is one we should store historically (MNQ, NQ, MES, ES)
isMNQ = str.contains(syminfo.ticker, "MNQ") or (syminfo.root == "MNQ")
isNQ = str.contains(syminfo.ticker, "NQ") or (syminfo.root == "NQ")
isMES = str.contains(syminfo.ticker, "MES") or (syminfo.root == "MES")
isES = str.contains(syminfo.ticker, "ES") or (syminfo.root == "ES")
isStoreableSymbol = isMNQ or isNQ or isMES or isES

// ════════════════════════════════════════════════════════════════════════════
// FVG DETECTION LOGIC
// ════════════════════════════════════════════════════════════════════════════

[time1m, low1m, high1m, prevTime1m, prevHigh1m, prevLow1m, prev2Time1m, prev2High1m, prev2Low1m] = request.security(syminfo.tickerid, "1", [time, low, high, time[1], high[1], low[1], time[2], high[2], low[2]], lookahead=barmerge.lookahead_off)

bool bullishGap = low1m > prev2High1m
bool bearishGap = high1m < prev2Low1m

date1m = dayofmonth(time1m, timezone)
month1m = month(time1m, timezone)
year1m = year(time1m, timezone)

gapHour = hour(prevTime1m, timezone)
gapMinute = minute(prevTime1m, timezone)
isInWindow = (gapHour == 9 and gapMinute >= 31) or (gapHour == 10) or (gapHour == 11 and gapMinute == 0)

// ════════════════════════════════════════════════════════════════════════════
// STORAGE ARRAYS
// ════════════════════════════════════════════════════════════════════════════

var array<int> gapTimes = array.new<int>()
var array<float> gapTops = array.new<float>()
var array<float> gapBottoms = array.new<float>()
var array<bool> gapIsBullish = array.new<bool>()

var int currentDayDate = 0
var int currentDayMonth = 0
var int currentDayYear = 0
var bool gapFoundForCurrentDay = false
var int currentDayGapTime = 0
var float currentDayGapTop = 0.0
var float currentDayGapBottom = 0.0
var bool currentDayGapIsBull = false

// ════════════════════════════════════════════════════════════════════════════
// PROCESS EACH BAR
// ════════════════════════════════════════════════════════════════════════════

bool newDay = (date1m != currentDayDate) or (month1m != currentDayMonth) or (year1m != currentDayYear)

if newDay and currentDayDate > 0
    if gapFoundForCurrentDay and currentDayGapTime > 0 and isStoreableSymbol
        array.unshift(gapTimes, currentDayGapTime)
        array.unshift(gapTops, currentDayGapTop)
        array.unshift(gapBottoms, currentDayGapBottom)
        array.unshift(gapIsBullish, currentDayGapIsBull)
        
        if array.size(gapTimes) > maxDaysToStore
            array.pop(gapTimes)
            array.pop(gapTops)
            array.pop(gapBottoms)
            array.pop(gapIsBullish)
    
    gapFoundForCurrentDay := false
    currentDayGapTime := 0
    currentDayGapTop := 0.0
    currentDayGapBottom := 0.0
    currentDayGapIsBull := false

currentDayDate := date1m
currentDayMonth := month1m
currentDayYear := year1m

if isInWindow and not gapFoundForCurrentDay
    if bullishGap
        gapFoundForCurrentDay := true
        currentDayGapTime := prev2Time1m
        currentDayGapTop := low1m
        currentDayGapBottom := prev2High1m
        currentDayGapIsBull := true
    else if bearishGap
        gapFoundForCurrentDay := true
        currentDayGapTime := prev2Time1m
        currentDayGapTop := prev2Low1m
        currentDayGapBottom := high1m
        currentDayGapIsBull := false

if barstate.islastconfirmedhistory
    if gapFoundForCurrentDay and currentDayGapTime > 0 and isStoreableSymbol
        bool alreadySaved = false
        if array.size(gapTimes) > 0
            for i = 0 to array.size(gapTimes) - 1
                if array.get(gapTimes, i) == currentDayGapTime
                    alreadySaved := true
                    break
        
        if not alreadySaved
            array.unshift(gapTimes, currentDayGapTime)
            array.unshift(gapTops, currentDayGapTop)
            array.unshift(gapBottoms, currentDayGapBottom)
            array.unshift(gapIsBullish, currentDayGapIsBull)
            
            if array.size(gapTimes) > maxDaysToStore
                array.pop(gapTimes)
                array.pop(gapTops)
                array.pop(gapBottoms)
                array.pop(gapIsBullish)

// ════════════════════════════════════════════════════════════════════════════
// LINE & LABEL MANAGEMENT
// ════════════════════════════════════════════════════════════════════════════

var array<line> topLines = array.new<line>()
var array<line> bottomLines = array.new<line>()
var array<line> midLines = array.new<line>()
var array<label> topLabels = array.new<label>()
var array<label> bottomLabels = array.new<label>()
var array<int> activeGapTimes = array.new<int>()

if showGaps
    // Create a temporary list of all gaps to display (Today + History)
    var int[] displayTimes = array.new<int>()
    var float[] displayTops = array.new<float>()
    var float[] displayBottoms = array.new<float>()
    var bool[] displayIsBull = array.new<bool>()
    var string[] displayNames = array.new<string>()
    
    array.clear(displayTimes)
    array.clear(displayTops)
    array.clear(displayBottoms)
    array.clear(displayIsBull)
    array.clear(displayNames)

    // Add Today's gap first (D0)
    if gapFoundForCurrentDay and currentDayGapTime > 0
        array.push(displayTimes, currentDayGapTime)
        array.push(displayTops, currentDayGapTop)
        array.push(displayBottoms, currentDayGapBottom)
        array.push(displayIsBull, currentDayGapIsBull)
        array.push(displayNames, "D0")

    // Add Historical gaps (D1, D2, etc.)
    int histCount = math.min(maxDaysToDisplay - (array.size(displayTimes) > 0 ? 1 : 0), array.size(gapTimes))
    if histCount > 0
        for i = 0 to histCount - 1
            array.push(displayTimes, array.get(gapTimes, i))
            array.push(displayTops, array.get(gapTops, i))
            array.push(displayBottoms, array.get(gapBottoms, i))
            array.push(displayIsBull, array.get(gapIsBullish, i))
            array.push(displayNames, "D" + str.tostring(i + 1))

    // Update or Create Drawing Objects
    int numGaps = array.size(displayTimes)
    if numGaps > 0
        for i = 0 to numGaps - 1
            int gTime = array.get(displayTimes, i)
            float gTop = array.get(displayTops, i)
            float gBot = array.get(displayBottoms, i)
            bool isB = array.get(displayIsBull, i)
            string dName = array.get(displayNames, i)
            color gCol = isB ? bullishColorDark : bearishColorDark
            
            // Check if we already have objects for this specific gap time
            int existingIdx = -1
            if array.size(activeGapTimes) > 0
                for j = 0 to array.size(activeGapTimes) - 1
                    if array.get(activeGapTimes, j) == gTime
                        existingIdx := j
                        break

            if existingIdx == -1
                // Create New
                line tl = line.new(gTime, gTop, time, gTop, xloc=xloc.bar_time, color=gCol, width=lineWidth)
                line bl = line.new(gTime, gBot, time, gBot, xloc=xloc.bar_time, color=gCol, width=lineWidth)
                
                // Create midpoint line (dashed, transparent, lighter)
                float gMid = (gTop + gBot) / 2
                color midCol = color.new(isB ? #90EE90 : #FFB6C1, 30)
                line ml = line.new(gTime, gMid, time, gMid, xloc=xloc.bar_time, color=midCol, width=1, style=line.style_dashed)
                
                // Create labels to the right of line end
                label tlb = label.new(bar_index + 3, gTop, dName, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, textcolor=gCol, color=color.new(gCol, 100), size=size.small)
                label blb = label.new(bar_index + 3, gBot, dName, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, textcolor=gCol, color=color.new(gCol, 100), size=size.small)
                
                array.push(topLines, tl)
                array.push(bottomLines, bl)
                array.push(midLines, ml)
                array.push(topLabels, tlb)
                array.push(bottomLabels, blb)
                array.push(activeGapTimes, gTime)
            else
                // Update Existing lines to end at current time
                line.set_x2(array.get(topLines, existingIdx), time)
                line.set_x2(array.get(bottomLines, existingIdx), time)
                line.set_x2(array.get(midLines, existingIdx), time)

    // Update ALL label positions on every bar to keep them sticky (to the right of line end)
    if array.size(topLabels) > 0
        for i = 0 to array.size(topLabels) - 1
            // Find the corresponding display info for this label
            int activeTime = array.get(activeGapTimes, i)
            string labelText = ""
            
            // Determine which day this is
            if gapFoundForCurrentDay and currentDayGapTime > 0 and activeTime == currentDayGapTime
                labelText := "D0"
            else
                // Find in historical gaps
                if array.size(gapTimes) > 0
                    for j = 0 to array.size(gapTimes) - 1
                        if array.get(gapTimes, j) == activeTime
                            labelText := "D" + str.tostring(j + 1)
                            break
            
            if labelText != ""
                label.set_x(array.get(topLabels, i), bar_index + 3)
                label.set_x(array.get(bottomLabels, i), bar_index + 3)
                label.set_text(array.get(topLabels, i), labelText)
                label.set_text(array.get(bottomLabels, i), labelText)

    // Cleanup objects that are no longer in the display list
    if array.size(activeGapTimes) > 0
        int k = 0
        while k < array.size(activeGapTimes)
            int activeTime = array.get(activeGapTimes, k)
            bool stillActive = false
            if array.size(displayTimes) > 0
                for m = 0 to array.size(displayTimes) - 1
                    if array.get(displayTimes, m) == activeTime
                        stillActive := true
                        break
            
            if not stillActive
                line.delete(array.get(topLines, k))
                line.delete(array.get(bottomLines, k))
                line.delete(array.get(midLines, k))
                label.delete(array.get(topLabels, k))
                label.delete(array.get(bottomLabels, k))
                array.remove(topLines, k)
                array.remove(bottomLines, k)
                array.remove(midLines, k)
                array.remove(topLabels, k)
                array.remove(bottomLabels, k)
                array.remove(activeGapTimes, k)
            else
                k += 1

//@version=6
indicator("first presented gaps", overlay=true, max_lines_count=500, max_labels_count=500)

// ════════════════════════════════════════════════════════════════════════════
// INPUTS
// ════════════════════════════════════════════════════════════════════════════

timezone = input.string("America/New_York", "Timezone", options=["America/New_York", "Europe/London", "UTC"], group="Settings")
maxDaysToDisplay = input.int(20, "Days to Display", minval=1, maxval=20, group="Display")
showGaps = input.bool(true, "Show Gaps", group="Display")
lineWidth = input.int(2, "Line Width", minval=1, maxval=5, group="Display")
bullishColorDark = input.color(#008000, "Bullish Color", group="Display")
bearishColorDark = input.color(#B22222, "Bearish Color", group="Display")

// Always store up to 20 days
maxDaysToStore = 20

// Check if symbol is one we should store historically (MNQ, NQ, MES, ES)
isMNQ = str.contains(syminfo.ticker, "MNQ") or (syminfo.root == "MNQ")
isNQ = str.contains(syminfo.ticker, "NQ") or (syminfo.root == "NQ")
isMES = str.contains(syminfo.ticker, "MES") or (syminfo.root == "MES")
isES = str.contains(syminfo.ticker, "ES") or (syminfo.root == "ES")
isStoreableSymbol = isMNQ or isNQ or isMES or isES

// ════════════════════════════════════════════════════════════════════════════
// FVG DETECTION LOGIC (GOD MODE)
// ════════════════════════════════════════════════════════════════════════════

findFirstFVG() =>
    gTop = float(na)
    gBot = float(na)
    gTime = int(na)
    gBull = bool(na)
    
    [t, l, h] = request.security_lower_tf(syminfo.tickerid, "1", [time, low, high])
    
    if not na(t) and array.size(t) >= 3
        for i = 2 to array.size(t) - 1
            float cL = array.get(l, i)
            float cH = array.get(h, i)
            float p2H = array.get(h, i - 2)
            float p2L = array.get(l, i - 2)
            int p2T = array.get(t, i - 2) // Start of sequence
            int p0T = array.get(t, i)     // End of sequence (presentation candle)
            
            // Time check: 
            // 1. First candle (p2T) must be >= 9:31
            // 2. Last candle (p0T) must be <= 10:59 (so it closes at 11:00)
            hStart = hour(p2T, timezone)
            mStart = minute(p2T, timezone)
            hEnd = hour(p0T, timezone)
            mEnd = minute(p0T, timezone)
            
            bool after930 = (hStart == 9 and mStart >= 31) or (hStart >= 10)
            bool before1100 = (hEnd < 11) // 10:59 is the last allowed starting minute
            
            if after930 and before1100
                if cL > p2H // Bullish
                    gTop := cL
                    gBot := p2H
                    gTime := array.get(t, i - 2)
                    gBull := true
                    break
                else if cH < p2L // Bearish
                    gTop := p2L
                    gBot := cH
                    gTime := array.get(t, i - 2)
                    gBull := false
                    break
    [gTime, gTop, gBot, gBull]

// Request FVG data from the 60m timeframe
[pTime, pTop, pBot, pBull] = request.security(syminfo.tickerid, "60", findFirstFVG(), lookahead=barmerge.lookahead_on)

// ════════════════════════════════════════════════════════════════════════════
// STORAGE LOGIC
// ════════════════════════════════════════════════════════════════════════════

var array<int> gapTimes = array.new<int>()
var array<float> gapTops = array.new<float>()
var array<float> gapBottoms = array.new<float>()
var array<bool> gapIsBullish = array.new<bool>()

// Add newly found gaps to the persistent arrays
if not na(pTime) and isStoreableSymbol
    int pDay = dayofmonth(pTime, timezone)
    int pMon = month(pTime, timezone)
    int pYr = year(pTime, timezone)
    
    int existingIdxForDay = -1
    if array.size(gapTimes) > 0
        for i = 0 to array.size(gapTimes) - 1
            int gT = array.get(gapTimes, i)
            if dayofmonth(gT, timezone) == pDay and month(gT, timezone) == pMon and year(gT, timezone) == pYr
                existingIdxForDay := i
                break
    
    if existingIdxForDay == -1
        // NEW DAY: Insert and keep sorted by time (descending: newest first)
        int insertIdx = 0
        if array.size(gapTimes) > 0
            for i = 0 to array.size(gapTimes) - 1
                if pTime > array.get(gapTimes, i)
                    break
                insertIdx := i + 1
        
        if insertIdx < maxDaysToStore
            array.insert(gapTimes, insertIdx, pTime)
            array.insert(gapTops, insertIdx, pTop)
            array.insert(gapBottoms, insertIdx, pBot)
            array.insert(gapIsBullish, insertIdx, pBull)
    else
        // DAY ALREADY HAS A GAP: Only update if the new one is EARLIER (the first presented)
        if pTime < array.get(gapTimes, existingIdxForDay)
            array.set(gapTimes, existingIdxForDay, pTime)
            array.set(gapTops, existingIdxForDay, pTop)
            array.set(gapBottoms, existingIdxForDay, pBot)
            array.set(gapIsBullish, existingIdxForDay, pBull)

    // Maintain max size
    if array.size(gapTimes) > maxDaysToStore
        array.pop(gapTimes)
        array.pop(gapTops)
        array.pop(gapBottoms)
        array.pop(gapIsBullish)

// ════════════════════════════════════════════════════════════════════════════
// DRAWING LOGIC
// ════════════════════════════════════════════════════════════════════════════

var array<line> topLines = array.new<line>()
var array<line> bottomLines = array.new<line>()
var array<line> midLines = array.new<line>()
var array<label> topLabels = array.new<label>()
var array<label> bottomLabels = array.new<label>()
var array<int> activeGapTimes = array.new<int>()

if showGaps and array.size(gapTimes) > 0
    int numToDisplay = math.min(maxDaysToDisplay, array.size(gapTimes))
    
    // Track which times we are displaying this bar
    var int[] currentDisplayTimes = array.new<int>()
    array.clear(currentDisplayTimes)

    for i = 0 to numToDisplay - 1
        int gTime = array.get(gapTimes, i)
        float gTop = array.get(gapTops, i)
        float gBot = array.get(gapBottoms, i)
        bool isB = array.get(gapIsBullish, i)
        
        // Determine label: D1 for today's gap, D2, D3 etc for history
        // Note: Since array is sorted descending, index 0 is always the most recent found
        string dName = "D" + str.tostring(i + 1)
        color gCol = isB ? bullishColorDark : bearishColorDark
        
        array.push(currentDisplayTimes, gTime)

        // Find if we already have a line for this gap
        int existingIdx = -1
        if array.size(activeGapTimes) > 0
            for j = 0 to array.size(activeGapTimes) - 1
                if array.get(activeGapTimes, j) == gTime
                    existingIdx := j
                    break

        if existingIdx == -1
            // Create New
            line tl = line.new(gTime, gTop, time, gTop, xloc=xloc.bar_time, color=gCol, width=lineWidth)
            line bl = line.new(gTime, gBot, time, gBot, xloc=xloc.bar_time, color=gCol, width=lineWidth)
            float gMid = (gTop + gBot) / 2
            color midCol = color.new(isB ? #90EE90 : #FFB6C1, 30)
            line ml = line.new(gTime, gMid, time, gMid, xloc=xloc.bar_time, color=midCol, width=1, style=line.style_dashed)
            label tlb = label.new(bar_index + 3, gTop, dName, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, textcolor=gCol, color=color.new(gCol, 100), size=size.small)
            label blb = label.new(bar_index + 3, gBot, dName, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, textcolor=gCol, color=color.new(gCol, 100), size=size.small)
            
            array.push(topLines, tl)
            array.push(bottomLines, bl)
            array.push(midLines, ml)
            array.push(topLabels, tlb)
            array.push(bottomLabels, blb)
            array.push(activeGapTimes, gTime)
        else
            // Update Existing
            line.set_x2(array.get(topLines, existingIdx), time)
            line.set_x2(array.get(bottomLines, existingIdx), time)
            line.set_x2(array.get(midLines, existingIdx), time)
            label.set_x(array.get(topLabels, existingIdx), bar_index + 3)
            label.set_x(array.get(bottomLabels, existingIdx), bar_index + 3)
            label.set_text(array.get(topLabels, existingIdx), dName)
            label.set_text(array.get(bottomLabels, existingIdx), dName)

    // Cleanup gaps no longer in the display range
    if array.size(activeGapTimes) > 0
        int k = 0
        while k < array.size(activeGapTimes)
            int activeTime = array.get(activeGapTimes, k)
            bool stillInDisplay = false
            if array.size(currentDisplayTimes) > 0
                for m = 0 to array.size(currentDisplayTimes) - 1
                    if array.get(currentDisplayTimes, m) == activeTime
                        stillInDisplay := true
                        break
            
            if not stillInDisplay
                line.delete(array.get(topLines, k))
                line.delete(array.get(bottomLines, k))
                line.delete(array.get(midLines, k))
                label.delete(array.get(topLabels, k))
                label.delete(array.get(bottomLabels, k))
                array.remove(topLines, k)
                array.remove(bottomLines, k)
                array.remove(midLines, k)
                array.remove(topLabels, k)
                array.remove(bottomLabels, k)
                array.remove(activeGapTimes, k)
            else
                k += 1
